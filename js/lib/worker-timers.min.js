(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));
})(this, (function (exports) { 'use strict';

    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {
      return function (set) {
        var number = generateUniqueNumber(set);
        set.add(number);
        return number;
      };
    };

    var createCache = function createCache(lastNumberWeakMap) {
      return function (collection, nextNumber) {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };

    /*
     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it
     * is fairly new.
     */
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {
      return function (collection) {
        var lastNumber = lastNumberWeakMap.get(collection);
        /*
         * Let's try the cheapest algorithm first. It might fail to produce a new
         * number, but it is so cheap that it is okay to take the risk. Just
         * increase the last number by one or reset it to 0 if we reached the upper
         * bound of SMIs (which stands for small integers). When the last number is
         * unknown it is assumed that the collection contains zero based consecutive
         * numbers.
         */
        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache(collection, nextNumber);
        }
        /*
         * If there are less than half of 2 ** 30 numbers stored in the collection,
         * the chance to generate a new random number in the range from 0 to 2 ** 30
         * is at least 50%. It's benifitial to use only SMIs because they perform
         * much better in any environment based on V8.
         */
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
          }
          return cache(collection, nextNumber);
        }
        // Quickly check if there is a theoretical chance to generate a new number.
        if (collection.size > MAX_SAFE_INTEGER) {
          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');
        }
        // Otherwise use the full scale of safely usable integers.
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
        }
        return cache(collection, nextNumber);
      };
    };

    var LAST_NUMBER_WEAK_MAP = new WeakMap();
    var cache = createCache(LAST_NUMBER_WEAK_MAP);
    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);

    exports.addUniqueNumber = addUniqueNumber;
    exports.generateUniqueNumber = generateUniqueNumber;

}));

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fast-unique-numbers')) :
    typeof define === 'function' && define.amd ? define(['exports', 'fast-unique-numbers'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.workerTimersBroker = {}, global.fastUniqueNumbers));
})(this, (function (exports, fastUniqueNumbers) { 'use strict';

    var isCallNotification = function isCallNotification(message) {
      return message.method !== undefined && message.method === 'call';
    };

    var isClearResponse = function isClearResponse(message) {
      return message.error === null && typeof message.id === 'number';
    };

    var load = function load(url) {
      // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
      var scheduledIntervalFunctions = new Map([[0, function () {}]]); // tslint:disable-line no-empty
      var scheduledTimeoutFunctions = new Map([[0, function () {}]]); // tslint:disable-line no-empty
      var unrespondedRequests = new Map();
      var worker = new Worker(url);
      worker.addEventListener('message', function (_ref) {
        var data = _ref.data;
        if (isCallNotification(data)) {
          var _data$params = data.params,
            timerId = _data$params.timerId,
            timerType = _data$params.timerType;
          if (timerType === 'interval') {
            var idOrFunc = scheduledIntervalFunctions.get(timerId);
            if (typeof idOrFunc === 'number') {
              var timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
              if (timerIdAndTimerType === undefined || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
                throw new Error('The timer is in an undefined state.');
              }
            } else if (typeof idOrFunc !== 'undefined') {
              idOrFunc();
            } else {
              throw new Error('The timer is in an undefined state.');
            }
          } else if (timerType === 'timeout') {
            var _idOrFunc = scheduledTimeoutFunctions.get(timerId);
            if (typeof _idOrFunc === 'number') {
              var _timerIdAndTimerType = unrespondedRequests.get(_idOrFunc);
              if (_timerIdAndTimerType === undefined || _timerIdAndTimerType.timerId !== timerId || _timerIdAndTimerType.timerType !== timerType) {
                throw new Error('The timer is in an undefined state.');
              }
            } else if (typeof _idOrFunc !== 'undefined') {
              _idOrFunc();
              // A timeout can be savely deleted because it is only called once.
              scheduledTimeoutFunctions["delete"](timerId);
            } else {
              throw new Error('The timer is in an undefined state.');
            }
          }
        } else if (isClearResponse(data)) {
          var id = data.id;
          var _timerIdAndTimerType2 = unrespondedRequests.get(id);
          if (_timerIdAndTimerType2 === undefined) {
            throw new Error('The timer is in an undefined state.');
          }
          var _timerId = _timerIdAndTimerType2.timerId,
            _timerType = _timerIdAndTimerType2.timerType;
          unrespondedRequests["delete"](id);
          if (_timerType === 'interval') {
            scheduledIntervalFunctions["delete"](_timerId);
          } else {
            scheduledTimeoutFunctions["delete"](_timerId);
          }
        } else {
          var message = data.error.message;
          throw new Error(message);
        }
      });
      var clearInterval = function clearInterval(timerId) {
        var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
        unrespondedRequests.set(id, {
          timerId: timerId,
          timerType: 'interval'
        });
        scheduledIntervalFunctions.set(timerId, id);
        worker.postMessage({
          id: id,
          method: 'clear',
          params: {
            timerId: timerId,
            timerType: 'interval'
          }
        });
      };
      var clearTimeout = function clearTimeout(timerId) {
        var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
        unrespondedRequests.set(id, {
          timerId: timerId,
          timerType: 'timeout'
        });
        scheduledTimeoutFunctions.set(timerId, id);
        worker.postMessage({
          id: id,
          method: 'clear',
          params: {
            timerId: timerId,
            timerType: 'timeout'
          }
        });
      };
      var setInterval = function setInterval(func, delay) {
        var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledIntervalFunctions);
        scheduledIntervalFunctions.set(timerId, function () {
          func();
          // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().
          if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {
            worker.postMessage({
              id: null,
              method: 'set',
              params: {
                delay: delay,
                now: performance.now(),
                timerId: timerId,
                timerType: 'interval'
              }
            });
          }
        });
        worker.postMessage({
          id: null,
          method: 'set',
          params: {
            delay: delay,
            now: performance.now(),
            timerId: timerId,
            timerType: 'interval'
          }
        });
        return timerId;
      };
      var setTimeout = function setTimeout(func, delay) {
        var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledTimeoutFunctions);
        scheduledTimeoutFunctions.set(timerId, func);
        worker.postMessage({
          id: null,
          method: 'set',
          params: {
            delay: delay,
            now: performance.now(),
            timerId: timerId,
            timerType: 'timeout'
          }
        });
        return timerId;
      };
      return {
        clearInterval: clearInterval,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        setTimeout: setTimeout
      };
    };

    exports.load = load;

}));

/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/worker-timers@8.0.0/build/es5/bundle.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("worker-timers-broker")):"function"==typeof define&&define.amd?define(["exports","worker-timers-broker"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).workerTimers={},e.workerTimersBroker)}(this,(function(e,t){"use strict";var r=function(e,t){var r=null;return function(){if(null!==r)return r;var o=new Blob([t],{type:"application/javascript; charset=utf-8"}),n=URL.createObjectURL(o);return r=e(n),setTimeout((function(){return URL.revokeObjectURL(n)})),r}}(t.load,'(()=>{var e={472:(e,t,r)=>{var o,n;void 0===(n="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);return void 0!==r&&(clearTimeout(r),e.delete(t),!0)},o=function(e){var r=t.get(e);return void 0!==r&&(clearTimeout(r),t.delete(e),!0)},n=function(e,t){var r=performance.now(),o=e+t-r-performance.timeOrigin;return{expected:r+o,remainingDelay:o}},i=function e(t,r,o,n){var i=o-performance.now();i>0?t.set(r,setTimeout(e,i,t,r,o,n)):(t.delete(r),postMessage({id:null,method:"call",params:{timerId:r,timerType:n}}))},a=function(t,r,o){var a=n(t,o),s=a.expected,u=a.remainingDelay;e.set(r,setTimeout(i,u,e,r,s,"interval"))},s=function(e,r,o){var a=n(e,o),s=a.expected,u=a.remainingDelay;t.set(r,setTimeout(i,u,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var n=t.id,i=t.params,u=i.timerId,d=i.timerType;if("interval"===d)postMessage({id:n,result:r(u)});else{if("timeout"!==d)throw new Error(\'The given type "\'.concat(d,\'" is not supported\'));postMessage({id:n,result:o(u)})}}else{if("set"!==t.method)throw new Error(\'The given method "\'.concat(t.method,\'" is not supported\'));var p=t.params,c=p.delay,m=p.now,l=p.timerId,v=p.timerType;if("interval"===v)a(c,l,m);else{if("timeout"!==v)throw new Error(\'The given type "\'.concat(v,\'" is not supported\'));s(c,l,m)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=n)}},t={};function r(o){var n=t[o];if(void 0!==n)return n.exports;var i=t[o]={exports:{}};return e[o](i,i.exports,r),i.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();');e.clearInterval=function(e){return r().clearInterval(e)},e.clearTimeout=function(e){return r().clearTimeout(e)},e.setInterval=function(){var e;return(e=r()).setInterval.apply(e,arguments)},e.setTimeout=function(){var e;return(e=r()).setTimeout.apply(e,arguments)}}));
//# sourceMappingURL=/sm/2a897fcdde23ea4836dddaf6cc7b949728ffac677cfe6c24f2bc363c855522b9.map